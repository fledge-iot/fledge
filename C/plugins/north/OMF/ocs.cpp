/*
 * Fledge OSIsoft ADH and OCS integration.
 * Implements the integration for the specific functionalities exposed by ADH and OCS
 *
 * Copyright (c) 2020-2025 Dianomic Systems
 *
 * Released under the Apache 2.0 Licence
 *
 * Author: Stefano Simonelli
 */

#include <string>
#include <vector>
#include <utility>

#include <ocs.h>
#include <string_utils.h>
#include <logger.h>
#include <simple_https.h>
#include <rapidjson/document.h>
#include "rapidjson/error/en.h"

using namespace std;
using namespace rapidjson;

OCS::OCS() : m_adh(false), m_nextAuthentication(std::chrono::steady_clock::time_point())
{
}

OCS::OCS(bool adh) : m_adh(adh), m_nextAuthentication(std::chrono::steady_clock::time_point())
{
}

// Destructor
OCS::~OCS()
{
}

/**
 * Extracts the OCS token from the JSON returned by the OCS API
 *
 * @param response  JSON message generated by the OCS API containing the OCS token
 *
 */
void OCS::extractToken(const string &response)
{
	Document JSon;

	ParseResult ok = JSon.Parse(response.c_str());
	if (!ok)
	{
		Logger::getLogger()->error("OCS token extract, invalid json - HTTP response :%s:", response.c_str());
	}
	else
	{
		if (JSon.HasMember("access_token"))
		{
			m_token = JSon["access_token"].GetString();
		}

		if (JSon.HasMember("expires_in"))
		{
			m_expiresIn = JSon["expires_in"].GetUint();
			Logger::getLogger()->debug("ADH token expires in %u seconds", m_expiresIn);
		}
		else
		{
			m_expiresIn = 0;
			Logger::getLogger()->warn("ADH authentication response does not include 'expires_in'");
		}
	}
}

/**
 * Calls the OCS/ADH API to retrieve the authentication token related to the the clientId and clientSecret
 *
 * @param clientId      Client Id code assigned by OCS/ADH using its GUI to the specific connection
 * @param clientSecret  Client Secret code assigned by OCS/ADH using its GUI to the specific connection
 * @param logMessage    If true, log error messages (default: true)
 * @return              HTTP Code
 *
 */
int OCS::retrieveToken(const string& clientId, const string& clientSecret, bool logMessage)
{
	string response;
	string payload;

	HttpSender *endPoint;
	vector<pair<string, string>> header;
	int httpCode = 400;

	endPoint = new SimpleHttps(m_adh ? ADH_HOST : OCS_HOST,
							   TIMEOUT_CONNECT,
							   TIMEOUT_REQUEST,
							   RETRY_SLEEP_TIME,
							   0);

	header.push_back( std::make_pair("Content-Type", "application/x-www-form-urlencoded"));
	header.push_back( std::make_pair("Accept", " text/plain"));

	payload =  PAYLOAD_RETRIEVE_TOKEN;

	StringReplace(payload, "CLIENT_ID_PLACEHOLDER",        urlEncode(clientId));
	StringReplace(payload, "CLIENT_SECRET_ID_PLACEHOLDER", urlEncode(clientSecret));

	// Anonymous auth
	string authMethod = "a";
	endPoint->setAuthMethod (authMethod);

	try
	{
		httpCode = endPoint->sendRequest("POST",
										 URL_RETRIEVE_TOKEN,
										 header,
										 payload);

		response = endPoint->getHTTPResponse();

		if (httpCode >= 200 && httpCode <= 399)
		{
			extractToken(response);
			Logger::getLogger()->debug("ADH authentication token of %u characters retrieved", m_token.size());
		}
		else if (logMessage)
		{
			Logger::getLogger()->error("Error in retrieving the authentication token from ADH - http :%d: :%s: ", httpCode, response.c_str());
		}
	}
	catch (const Unauthorized &e)
	{
		// Log authentication failures regardless of 'logMessage'
		Logger::getLogger()->error("Unable to authenticate with AVEVA Data Hub");
		httpCode = 401;
	}
	catch (exception &ex)
	{
		if (logMessage)
		{
			Logger::getLogger()->error("Error in retrieving the authentication token from ADH - error :%s: ", ex.what());
		}
	}

	delete endPoint;

	return httpCode;
}

/**
 * Calls the ADH API to retrieve the authentication token
 *
 * @param    logMessage	If true, log error messages (default: true)
 * @return   token      Authorization token
 */
string OCS::OCSRetrieveAuthToken(const string &clientId, const string &clientSecret, bool logMessage)
{
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();

	if (now >= m_nextAuthentication)
	{
		int httpCode = retrieveToken(clientId, clientSecret, logMessage);
		if (httpCode >= 200 && httpCode <= 399)
		{
			// Set the next authentication check time only if this attempt was successful.
			// Otherwise, leave the next authentication check as-is so retry will be immediate.
			// Authentication check time is half the expiry time to avoid being near the deadline.
			m_nextAuthentication = now + std::chrono::seconds(m_expiresIn / 2);
		}
		return m_token;
	}
	else
	{
		return m_token;
	}
}
